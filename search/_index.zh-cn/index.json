[{"categories":null,"content":"Introduction friTap is a powerful tool designed to assist security researchers in analyzing network traffic protected by SSL/TLS. By automating key extraction and decrypting traffic at runtime, friTap simplifies complex workflows, making it especially valuable for malware analysis and the investigation of data privacy practices in mobile and desktop applications. For more technical background, see this in-depth post or explore the source code directly on GitHub.\nA core feature of friTap is its ability to extract TLS session keys across various platforms and TLS implementations, allowing seamless integration into traffic analysis pipelines using tools like Wireshark, Zeek and others. However, certain situations‚Äîsuch as statically linked or stripped binaries‚Äîpose additional challenges for dynamic instrumentation.\nThis is especially common in Android applications using Cronet (libcronet.so) or Flutter (libflutter.so), where BoringSSL is statically linked and stripped of symbols. In such cases, direct function hooking becomes infeasible without symbol information. Fortunately, friTap supports a technique known as hooking by byte patterns, enabling reliable function interception based on instruction-level signatures.\nHooking via Byte Patterns When symbol resolution is not possible due to static linking or symbol stripping, friTap supports hooking functions via byte patterns. This approach involves scanning the memory of the target process for predefined instruction sequences that uniquely identify key TLS-related functions.\nYou can provide friTap with a JSON file containing these byte patterns using the --patterns \u0026lt;byte-pattern-file.json\u0026gt; option. Each pattern is categorized by its role in the TLS handshake or encryption flow, including:\nDump-Keys Install-Key-Log-Callback KeyLogCallback-Function SSL_Read SSL_Write Each category can define both a primary and a fallback pattern to increase reliability across different binary versions and architectures.\nHere\u0026rsquo;s an example JSON snippet for the Dump-Keys category:\n\u0026#34;Dump-Keys\u0026#34;: { \u0026#34;primary\u0026#34;: \u0026#34;AA BB CC DD EE FF ...\u0026#34;, \u0026#34;fallback\u0026#34;: \u0026#34;FF EE DD CC BB AA ...\u0026#34; } Primary Pattern: The preferred pattern for identifying the target function. Fallback Pattern: A backup used when the primary fails to match. The Dump-Keys category is particularly important, as it targets functions responsible for logging or exporting TLS session keys. Once matched, friTap uses internal logic to parse key material directly from memory, enabling live decryption of encrypted sessions.\nAutomating Pattern Extraction with BoringSecretHunter To streamline the process of identifying byte patterns in statically linked BoringSSL binaries, we developed a companion tool: BoringSecretHunter . This Ghidra-based analysis utility scans the binary for the ssl_log_secret() function‚Äîcommonly used internally in BoringSSL for logging key material‚Äîand outputs a ready-to-use byte pattern for hooking with friTap.\nBoringSecretHunter is especially useful for analyzing stripped binaries on Android, where traditional reverse engineering techniques are time-consuming. Once the relevant pattern is identified, you can simply feed it to friTap and begin live TLS key extraction‚Äîeven in challenging CTF or malware sandboxing environments.\nBuilding BoringSecretHunter To get started, build the Docker image provided in the repository. Run the following command from the project root:\ndocker build -t boringsecrethunter . Usage Once the Docker image is built, you can analyze a target binary by mounting it into the container. For example, to scan a statically linked Cronet library located in the binary/ folder:\ndocker run --rm \\ -v \u0026#34;$(pwd)/binary\u0026#34;:/usr/local/src/binaries \\ -v \u0026#34;$(pwd)/results\u0026#34;:/host_output \\ boringsecrethunter You should see output similar to the following:\ndocker run --rm -v \u0026#34;$(pwd)/binary\u0026#34;:/usr/local/src/binaries -v \u0026#34;$(pwd)/results\u0026#34;:/host_output boringsecrethunter Analyzing libcronet.113.0.5672.61.so... BoringSecretHunter ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£¥‚†æ‚†õ‚¢â‚£â‚£â‚£â‚°â‚†õ‚†∑‚£¶‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£¥‚†ã‚£†‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚£ø‚£∂‚£å‚†π‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚†Å‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ü‚†â‚†ª‚£ß‚†ò‚£∑‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚°á‚¢∞‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚°á‚¢∏‚£ø‚†õ‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£∑‚†Ä‚¢ø‚°Ü‚†à‚†õ‚†ª‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£ß‚°Ä‚†ª‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢º‚†ø‚£¶‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚†ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£¶‚†Ä‚†Ä‚†à‚†â‚†õ‚†ì‚†≤‚†∂‚†ñ‚†ö‚†ã‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚†ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚†ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Ä‚£æ‚£ø‚£ø‚†ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚£Ñ‚†à‚†õ‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä Identifying the ssl_log_secret() function for extracting key material using Frida. Version: 1.0.2 by Daniel Baier [*] Start analyzing binary libcronet.113.0.5672.61.so (CPU Architecture: AARCH64). This might take a while ... [*] Target function identified (ssl_log_secret): Function label: FUN_00493BB0 Function offset: 00493BB0 (0X493BB0) Byte pattern for frida (friTap): 3F 23 03 D5 FF C3 01 D1 FD 7B 04 A9 F6 57 05 A9 F4 4F 06 A9 FD 03 01 91 08 34 40 F9 08 11 41 F9 C8 07 00 B4 Once this pattern is extracted, you‚Äôre ready to integrate it into friTap for live decryption.\nfriTap Example for a shared object not supported by friTap IDA Pro Screenshot\n","permalink":"https://monkeywave.github.io/posts/boringsecrethunter-hooking-boringssl-on-android/","tags":["TLS","TLS Decryption"],"title":"Intercepting Android's Encrypted Traffic: Hooking BoringSSL with friTap"},{"categories":null,"content":"Hi there! üëã\nI\u0026rsquo;m a mobile security researcher passionate about automating and optimizing reverse engineering. My work focuses on two key areas: network decryption and mobile malware analysis, with the goal of simplifying security analysis to lower the barriers for beginners and help make the world a safer and better place.\nüî≠ What I‚Äôm currently working on:\nfriTap ‚Äî A powerful tool to facilitate network decryption for (mobile) apps. üå± I‚Äôm constantly learning and exploring new ways to simplify TLS and end-to-end (E2E) decryption.\n‚öôÔ∏è My mission is to make security analysis more accessible, reduce the barriers to entry, and contribute to a safer, more secure world. üëØ I‚Äôm always open to collaborating on cool new ideas related to mobile app analysis!\nIf you‚Äôd like to support my work, help me develop more tools, and contribute to a more transparent security landscape, feel free to buy me a coffee ‚Äî every bit fuels the mission! ‚òï‚ú®\n","permalink":"https://monkeywave.github.io/about/","tags":null,"title":"About"},{"categories":null,"content":"multilingual‰∏≠ÊñáÊµãËØïÈ°µÈù¢\n","permalink":"https://monkeywave.github.io/about.zh-cn/","tags":null,"title":"ÂÖ≥‰∫é"},{"categories":null,"content":"","permalink":"https://monkeywave.github.io/manifest.json","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://monkeywave.github.io/search/_index.de/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://monkeywave.github.io/search/_index.es/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://monkeywave.github.io/search/_index.fr/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://monkeywave.github.io/search/_index.hi/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://monkeywave.github.io/search/_index.jp/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://monkeywave.github.io/search/_index.nl/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://monkeywave.github.io/search/_index.pl/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://monkeywave.github.io/search/_index.ru/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://monkeywave.github.io/search/_index.zh-cn/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://monkeywave.github.io/categories/with-slug/with-slug/","tags":null,"title":"Ëá™ÂÆö‰πâ Slug ÁöÑÂàÜÁ±ª"},{"categories":null,"content":"","permalink":"https://monkeywave.github.io/tags/custom/custom/","tags":null,"title":"Èöè‰æø‰∏Ä‰∏™Ê†áÁ≠æ"}]